import { writeFile, mkdir, access } from 'node:fs/promises';
import { resolve, dirname } from 'node:path';
import yaml from 'js-yaml';
import { logger } from '../../utils/logger.js';

/**
 * Check if a file exists.
 * @param {string} p - Path to check.
 * @returns {Promise<boolean>}
 */
async function exists(p) {
  try {
    await access(p);
    return true;
  } catch {
    return false;
  }
}

/**
 * Build the operabase.yaml config object from wizard answers.
 * @param {object} answers - Wizard answers.
 * @returns {object} Config object ready for YAML serialization.
 */
function buildConfig(answers) {
  const config = {
    version: '1.0',
    name: answers.projectName || 'My Project',
    language: answers.language || 'en',
  };

  // Multi-tenant
  if (answers.multi_tenant) {
    config.multi_tenant = true;
    config.tenant_discovery = 'filesystem';
    config.tenant_gate = 'mandatory';
  }

  // Composio
  if (answers.composio) {
    config.composio = { enabled: true };
  }

  // Memory
  config.memory = {
    global: 'memory/MEMORY.md',
    squad_pattern: 'squads/{squad}/memory/{agent}.md',
  };

  // Obsidian
  if (answers.obsidian) {
    config.obsidian = {
      enabled: true,
      vault_path: answers.obsidian_vault_path || './vault',
      vault_name: 'Knowledge Vault',
      date_format: 'DD-MM-YYYY',
      structure: {
        inbox: '00-Inbox',
        projects: '01-Projects',
        resources: '03-Resources',
        daily: '05-Daily',
        journal: '08-Journal',
      },
      vault_git: answers.obsidian_vault_git || false,
    };
  }

  // Error handling
  config.error_handling = {
    default_strategy: 'ESCALATE',
    retryable_errors: ['timeout', 'rate_limit', 'ECONNRESET'],
    max_retries: 2,
    retry_delay_seconds: 5,
  };

  // Squads
  config.squads = { core: [], extras: [] };

  if (answers.dev_squad === 'basic') {
    config.squads.core.push('dev-squad');
  } else if (answers.dev_squad === 'complete') {
    config.squads.core.push('full-dev-squad');
  }

  if (answers.extra_squads && answers.extra_squads.length > 0) {
    config.squads.extras = answers.extra_squads.map((s) => `${s}-squad`);
  }

  // Quality gates
  config.gates = {
    pre_commit: ['npm run lint', 'npm run typecheck', 'npm test'],
    pre_push: ['npm run build'],
  };

  // Authority
  config.authority = {
    git_local: ['all'],
    git_push: ['devops'],
    git_pr: ['devops'],
    create_stories: ['pm', 'po', 'sm'],
    architecture_decisions: ['architect'],
    quality_verdicts: ['qa'],
  };

  return config;
}

/**
 * Generate operabase.yaml in the target directory.
 * @param {string} targetDir - Project root.
 * @param {object} answers - Wizard answers.
 * @returns {Promise<string|null>} Relative path of created file, or null if skipped.
 */
export async function generateConfig(targetDir, answers) {
  const filePath = resolve(targetDir, 'operabase.yaml');

  if (await exists(filePath)) {
    logger.warn('Skipped (already exists): operabase.yaml');
    return null;
  }

  const config = buildConfig(answers);

  const header = [
    '# operabase.yaml - Central configuration for your Operabase project',
    '# Schema: schemas/operabase.schema.json',
    '# Generated by: npx operabase init',
    '',
  ].join('\n');

  const yamlContent = yaml.dump(config, {
    indent: 2,
    lineWidth: 120,
    noRefs: true,
    sortKeys: false,
    quotingType: '"',
    forceQuotes: false,
  });

  await mkdir(dirname(filePath), { recursive: true });
  await writeFile(filePath, header + yamlContent, 'utf-8');

  logger.success('Created: operabase.yaml');
  return 'operabase.yaml';
}
